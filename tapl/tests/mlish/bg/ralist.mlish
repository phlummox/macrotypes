#lang s-exp "../../../mlish.rkt"
(require "../../rackunit-typechecking.rkt")

;; -----------------------------------------------------------------------------
;; TODO how to match default empty list?

(define-type (Option A)
  (None)
  (Some A))

(define-type (List A)
 [Nil]
 [∷ A (List A)])

;; -----------------------------------------------------------------------------

(define-type (Tree A)
  (Leaf A)
  (Node Int (Tree A) (Tree A)))

(define-type (Digit A)
  (Zero)
  (One (Tree A)))

(define-type (BinaryList A)
  (BL (List (Digit A))))

(define (size (t : (Tree A)) → Int)
  (match t with
   (Leaf x -> 1)
   (Node w t1 t2 -> w)))

(define (link (t1 : (Tree A)) (t2 : (Tree A)) → (Tree A))
  (Node (+ (size t1) (size t2)) t1 t2))

(define (consTree (t : (Tree A)) (x* : (List (Digit A))) → (List (Digit A)))
  (match x* with
   (Nil -> (∷ (One t) Nil))
   (∷ h ts ->
    (match h with
     (Zero -> (∷ (One t) ts))
     (One t2 -> (∷ Zero (consTree (link t t2) ts)))))))


;; TODO τ_e bad syntax when using `match2`
(define (unconsTree (d* : (List (Digit A))) → (Option (× (Tree A) (List (Digit A)))))
  (match d* with
   (Nil -> None)
   (∷ d*-hd d*-tl ->
    (match d*-hd with
     (One t ->
      (match d*-tl with
       (Nil -> (Some (tup t Nil)))
       (∷ a b -> (Some (tup t (∷ Zero d*-tl))))))
     (Zero ->
      (match (unconsTree d*-tl) with
       (None -> None)
       (Some udt ->
        (match udt with
         (a ts ->
          (match a with
           (Leaf x -> (None {(× (Tree A) (List (Digit A)))}))
           (Node x t1 t2 ->
            (Some (tup t1 (∷ (One t2) ts))))))))))))))

(define (bl-empty → (BinaryList A))
  (BL Nil))

(define (bl-isEmpty (b : (BinaryList A)) → Bool)
  (match b with
   (BL x* ->
    (match x* with
     (Nil -> #t)
     (∷ a b -> #f)))))

(define (bl-cons (x : A) (b : (BinaryList A)) → (BinaryList A))
  (match b with
   (BL ts -> (BL (consTree (Leaf x) ts)))))

(define (bl-head (b : (BinaryList A)) → (Option A))
  (match b with
   (BL ts ->
    (match (unconsTree ts) with
     (None -> None)
     (Some xy ->
      (match xy with
       (x y ->
        (match x with
         (Leaf x -> (Some x))
         (Node a b c -> (None {A}))))))))))

(define (bl-tail (b : (BinaryList A)) → (Option (BinaryList A)))
  (match b with
   (BL ts ->
    (match (unconsTree ts) with
     (None -> None)
     (Some xy ->
      (match xy with
       (x ts2 -> (Some (BL ts2)))))))))

(define (bl-lookup (i : Int) (b : (BinaryList A)) → (Option A))
  TODO)

(define (bl-update (i : Int) (y : A) (b : (BinaryList A)) → (Option (BinaryList A)))
  TODO)
