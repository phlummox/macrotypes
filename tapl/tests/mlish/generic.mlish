#lang s-exp "../../mlish.rkt"
(require "../rackunit-typechecking.rkt")

(define-typeclass (Eq X)
  [== : (→ X X Bool)])

(define-instance (Eq Int)
  [== =])

(define (test [x : X] #:where (Eq X) -> X) x)

(check-type (== 1 2) : Bool -> (= 1 2))
(check-type (== 1 2) : Bool -> #f)
(check-type (== 2 2) : Bool -> (= 2 2))
(check-type (== 2 2) : Bool -> #t)
(typecheck-fail (== "1" "1")
  #:with-msg "== operation undefined for input types: String, String")

(define-instance (Eq String) ; test use of lambda on rhs
  [== (λ ([x : String] [y : String]) 
        (string=? x y))])

(check-type (== "1" "2") : Bool -> (string=? "1" "2"))
(check-type (== "1" "2") : Bool -> #f)
(check-type (== "2" "2") : Bool -> (string=? "2" "2"))
(check-type (== "2" "2") : Bool -> #t)

(check-type (λ ([x : X] #:where (Eq X)) 
              (== x x))
  : (=>/test (Eq X) (→ X Bool)))

(check-type ((λ ([x : X] #:where (Eq X)) (== x x)) 1) : Bool -> #t)
(check-type ((λ ([x : X] #:where (Eq X)) (== x x)) "1") : Bool -> #t)
(typecheck-fail ((λ ([x : X] #:where (Eq X)) (== x x)) #f)
 #:with-msg
 "Eq Bool.*instance undefined.*Cannot instantiate function with constraints.*Eq X.*with.*X : Bool")

;; TODO?: fix name clash of generic op and concrete op
(define-typeclass (Ord X)
  [lt : (→ X X Bool)]
  [lte : (→ X X Bool)]
  [gt : (→ X X Bool)]
  [gte : (→ X X Bool)])

(define-instance (Ord Int)
  [lt <] [lte <=] [gt >] [gte >=])

;; missing typeclass constraint
(typecheck-fail (λ ([x : X]) (== x x))
  #:with-msg "== operation undefined for input types: X, X")
(typecheck-fail (λ ([x : X]) (lte x x)) 
  #:with-msg "lte operation undefined for input types: X, X")
;; wrong typeclass constraint
(typecheck-fail (λ ([x : Y] #:where (Ord Y)) (== x x))
  #:with-msg "== operation undefined for input types: Y, Y")
(typecheck-fail (λ ([x : Y] #:where (Eq Y)) (gt x x))
  #:with-msg "gt operation undefined for input types: Y, Y")

(check-type (λ ([x : Y] #:where (Ord Y)) (lte x x))
  : (=>/test (Ord Y) (→ Y Bool)))
(check-type (λ ([x : Y] #:where (Ord Y)) (lt x x))
  : (=>/test (Ord Y) (→ Y Bool)))
(check-type (λ ([x : Y] #:where (Ord Y)) (gte x x))
  : (=>/test (Ord Y) (→ Y Bool)))
(check-type (λ ([x : Y] #:where (Ord Y)) (gt x x))
  : (=>/test (Ord Y) (→ Y Bool)))

(check-type (λ ([x : Y] [y : Y] #:where (Ord Y)) (lt x x))
  : (=>/test (Ord Y) (→ Y Y Bool)))
(check-type (λ ([x : Y] [y : Y] #:where (Ord Y)) (lt x y))
  : (=>/test (Ord Y) (→ Y Y Bool)))
(check-type (λ ([x : Y] #:where (Ord Y) (Eq Y)) 
              (lt x x))
  : (=>/test (Ord Y) (Eq Y) (→ Y Bool)))
(check-type (λ ([x : Y] #:where (Ord Y) (Eq Y)) 
              (== x x))
  : (=>/test (Ord Y) (Eq Y) (→ Y Bool)))

(check-type (λ ([x : Y] #:where (Ord Y) (Eq Y)) 
              (and (== x x) (lte x x)))
  : (=>/test (Ord Y) (Eq Y) (→ Y Bool)))

;; ;; todo: not working; results in dup ids
;; #;(check-type (λ ([x : X] [y : Y] #:where (Ord X) (Ord Y)) (< x y))
;;   : (=>/test (Ord Y) (→ Y Y Bool)))

(define (f [x : X] #:where (Eq X) -> Bool)
  (== x x))
(check-type (f 1) : Bool -> #t)
(check-type (f "1") : Bool -> #t)
(typecheck-fail (f #f) 
 #:with-msg
 "Eq Bool.*instance undefined.*Cannot instantiate function with constraints.*Eq X.*with.*X : Bool")

(define-instance (Ord String)
  [lt string<?] [lte string<=?] [gt string>?] [gte string>=?])
(check-type (lt "1" "2") : Bool -> #t)
(define (f2 [x : X] [y : X] #:where (Ord X) -> Bool)
  (lte x y))
(check-type (f2 1 2) : Bool -> #t)
(check-type (f2 "1" "2") : Bool -> #t)
(typecheck-fail (f2 1 "2"))

(define-typeclass (Num X)
  [add : (→ X X X)]
  [sub : (→ X X X)]
  [mul : (→ X X X)])

(typecheck-fail
  (define-instance (Num Int)
    [add +] [sub -] [mul fl*])
 #:with-msg (string-append "Type error defining typeclass instance \\(Num Int\\).*"
              (expected "(→ Int Int Int), (→ Int Int Int), (→ Int Int Int)"
                #:given "(→ Int Int Int), (→ Int Int Int), (→ Float Float Float)")))

(define-instance (Num Int)
  [add +] [sub -] [mul *])
(define-instance (Num Float)
  [add fl+] [sub fl-] [mul fl*])

(define (square [x : X] #:where (Num X) -> X)
  (mul x x))
(check-type (square 5) : Int -> 25)
(check-type (square 2.5) : Float -> 6.25)
;; "propagation" of typeclass constraints to other constrained fns
(define (square2 [x : X] #:where (Num X) -> X)
  (square x))
(check-type (square2 5) : Int -> 25)
(check-type (square2 2.5) : Float -> 6.25)
#;(define (squares [xy : (× X Y)] #:where (Num X) (Num Y) -> (× X Y))
  (match2 xy with
   [(x,y) -> (tup (square x) (square y))]))

;; --------------------------------------------------

(define-type (TypeA X) (A [x : X] [y : X]))

;; constraint of nested tyvar
(define (test-a1 [a : (TypeA X)] #:where (Eq X) -> Bool)
  (== (A-x a) (A-y a)))
(check-type (test-a1 (A 1 2)) : Bool -> #f)
(check-type (test-a1 (A "1" "2")) : Bool -> #f)
(typecheck-fail (test-a1 (A #t #f))
 #:with-msg
"Eq Bool.*instance undefined.*Cannot instantiate function with constraints.*Eq X.*with.*X : Bool")

(define (test-a2 [a : (TypeA X)] [fa : (→ (TypeA X) X)] #:where (Eq X) -> Bool)
  (== (fa a) (fa a)))

(check-type (test-a2 (A 1 2) (inst A-x Int)) : Bool -> #t)
(check-type (test-a2 (A "1" "2") (inst A-x String)) : Bool -> #t)

(define-type (Heap X)
  Emp
  (H X))

(define (hf [h : (Heap X)] #:where (Ord X) -> Bool)
  (match h with
   [Emp -> #f]
   [H x -> (lte x x)]))

(check-type (hf (H 1)) : Bool -> #t)
(typecheck-fail (hf (H #f)) 
 #:with-msg 
 "Ord Bool.*instance undefined.*Cannot instantiate function with constraints.*Ord X.*with.*X : Bool")


;; type classes for non-base types
(define-instance (Eq X) => (Eq (List X))
 [== (λ ([l1 : (List X)] [l2 : (List X)])
       (match2 (tup l1 l2) with
        [(nil,nil) -> #t]
        [((x :: xs),(y :: ys)) -> (and (== x y) (== xs ys))]
        [_ -> #f]))])

;; nil and nil
(check-type (== (nil {Int}) (nil {Int})) : Bool -> #t)
;; TODO: better err msg?
;; as of 2016-04-04: "== operation undefined for input types: Int, Bool"
;; should somehow indicate that the two values are not equal because types differ?
(typecheck-fail (== (nil {Int}) (nil {Bool})))
;; nil and non-nil
(check-type (== (nil {Int}) (list 1)) : Bool -> #f)
(check-type (== (nil {Int}) (cons 1 nil)) : Bool -> #f)
(check-type (== (nil {Int}) (cons 1 (cons 2 nil))) : Bool -> #f)
;; non-nil and nil
(check-type (== (list 1) (nil {Int})) : Bool -> #f)
(check-type (== (cons 1 nil) (nil {Int})) : Bool -> #f)
(check-type (== (cons 1 (cons 2 nil)) (nil {Int})) : Bool -> #f)
;; non-nil and non-nil
(check-type (== (list 1) (list 1)) : Bool -> #t)
(check-type (== (cons 1 nil) (list 1)) : Bool -> #t)
(check-type (== (list 1) (cons 1 nil)) : Bool -> #t)
(check-type (== (list 1) (list 1 2)) : Bool -> #f)
(check-type (== (list 1 2) (list 1)) : Bool -> #f)
(check-type (== (list 1 2) (list 1 2)) : Bool -> #t)
(check-type (== (list 1 2) (list 1 3)) : Bool -> #f)
(check-type (== (list 1 3) (list 1 2)) : Bool -> #f)

(define (list-eq1 [l1 : (List X)] [l2 : (List X)] #:where (Eq X) -> Bool)
  (== l1 l2))

(check-type (list-eq1 (nil {Int}) (nil {Int})) : Bool -> #t)
(check-type (list-eq1 (nil {Int}) (list 1)) : Bool -> #f)
(check-type (list-eq1 (list 1) (nil {Int})) : Bool -> #f)
(check-type (list-eq1 (list 1) (list 1)) : Bool -> #t)
(check-type (list-eq1 (list 1) (list 2)) : Bool -> #f)
(check-type (list-eq1 (list 1) (list 1 2)) : Bool -> #f)

;; TODO: #:where TC, where TC has a tycon, like #:where (List X)
;; still doesnt work I dont think
#;(define (list-eq2 [l1 : (List X)] [l2 : (List X)] #:where (List X) -> Bool)
  (== l1 l2))
