2016-09-02 --------------------

Is concrete? broken?
- ie, Is it correct to determine concreteness from only outermost constructor?
- eg, an equal? that returns CBool based on concrete? inputs is not correct:
  (equal? (list i) (list 1)) => (= i 1)
  - is this a problem with concrete? or equal?

2016-08-31 --------------------

Rosette TODO:
- fix documentation of synthesize
  - #:forall accepts everything, not just constant?s
- doc typo: core
 - Returns the unsatisfiable core stored in the given satisfiable solution

Rosette use case questions:
- does the predicate in define-symbolic need to be an arbitrary expression?

2016-08-31 --------------------

Adding typed define/debug, debug (from query/debug), render (from lib/query):
- revealed problems with the way Rosette tracks source locations
  - in query/debug.rkt: https://github.com/emina/rosette/blob/cb877b9094f368c5f392518e7538ae8a061433a2/rosette/query/debug.rkt#L38
  - specifically, make-variable-like-transformer does not preserve src loc 
  properly, see: https://github.com/emina/rosette/issues/40

Workaround: manually set the src loc in #%app to surface program
- this causes taint problems bc rosette #%app uses syntax-rules, which taints 
  its output, which causes problems when we try to destructure it
minimal example:
#lang racket
(require (for-syntax syntax/parse))
(define-syntax-rule (mac x)
  (#%app add1 x))
(define-syntax test
  (syntax-parser
    [(_ x)
     #:with e (local-expand #'(mac x) 'expression null)
     (datum->syntax #'e (syntax-e #'e))]))
(test 1)
- calling syntax-disarm on the expanded pieces of a Rosette #%app appears to
  prevent the taint errors

2016-08-29 --------------------

Interesting parts of Typed Rosette
- only need a single U symbolic constructor
- assert-type, using cast-type and assertion store

2016-08-25 --------------------

TODOs:
- add pred properties to types 
 - use it to validate given pred in define-symbolic
 - STARTED 2016-08-25
 - alternative: don't require type, but associate type with pred?
   - advantage: soundness
   - disadvantage: cannot compute pred in define-symbolic
     - Rosette users won't care?
     - TODO: add extra type rules to propagate 'typefor tag
- implement assert-type, which adds to the assertion store
 - DONE 2016-08-25
- add polymorphism
 - regular polymorphism
- extend BV type with a size
 - requires BV-size-polymorpism?
- add Any type?
 - STARTED 2016-08-26
- support internal definition contexts
- fix type of Vector and List to differentiate homogeneous/hetero
  - 2016-09-01: add CList for hetero lists
- variable arity polymorphism
- CSolution
   - DONE 2016-08-30
- make libs have appropriate require paths
  - eg typed/rosette/query/debug
- make typed/rosette a separate pkg
  - depends on macrotypes and rosette
- create version of turnstile that does not provide #%module-begin
  - eg rename existing turnstile to turnstile/lang?
- remove my-this-syntax stx param
- add symbolic True and False?
- orig stx prop confuses distinction between symbolic and non-sym values
- use variance information in type constructors?
  - instead of special-casing individual constructors
- ok to say "Rosette type" in type err msgs?

2016-08-25 --------------------

** Problem:

The following subtyping relation holds but is potentially unintuitive for a 
programmer:

(U Int Bool) <: (U CInt Bool)

** Possible Solutions:
1) leave as is
2) allow only symbolic arguments to user-facing U constructor
 - user-facing U constructor expands to U** flattening constructor,
   which then expands to internal U* constructor
 - disadvantage: an if expression will expose the internal U** constructor,
   since if may need to create a symbolic union from potentially concrete types

Choosing #1 for now.
